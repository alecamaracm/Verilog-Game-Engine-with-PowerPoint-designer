using GemBox.Presentation;
using Microsoft.VisualBasic;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace PowerPointVerilogEngineDesigner
{
    public partial class Form1 : Form
    {
        PresentationDocument mainDocument;
        List<PresentationDocument> referenceDocuments = new List<PresentationDocument>();

        string currentProjectFilePath = "";
        string currentProjectFolderPath = "";

        bool isUpdated = true;
        FileSystemWatcher watcher = new FileSystemWatcher();

        List<string> arrowMovings = new List<string>();
        List<string> wasdMovings = new List<string>();
        List<string> bouncings = new List<string>();

        List<ResetLocations> resetLocations = new List<ResetLocations>();

        Dictionary<string,MovingProperties> movingProperties = new Dictionary<string,MovingProperties>();

        List<MemoryBitmaps> bitmapsToWrite = new List<MemoryBitmaps>();

        Dictionary<string, List<Collideables>> collideables = new Dictionary<string, List<Collideables>>();

        List<string> skipY = new List<string>();

        List<string> visibles = new List<string>();
        bool working = false;

        public Form1(bool upd)
        {
            isUpdated = !upd;
            InitializeComponent();
            Console.SetOut(new MultiTextWriter(new ControlWriter(textBoxOutput), Console.Out));
            ComponentInfo.SetLicense("FREE-LIMITED-KEY");
        }

        private void button1_Click(object sender, EventArgs e)
        {
           
            if (working == true) return;
            if(currentProjectFilePath=="")
            {
                Interaction.MsgBox("Please select a project or create one first", MsgBoxStyle.Exclamation);
                return;
            }
            if (isUpdated == false) Interaction.MsgBox("UPDATE, UPDATE, UPDATE, EXTERMINATE",MsgBoxStyle.Critical);

            if (checkBoxClearLog.Checked) textBoxOutput.Clear();
            pictureBox1.Visible = true;
            working = true;
            Task.Run(() => {
                movingProperties.Clear();
                wasdMovings.Clear();
                arrowMovings.Clear();
                bouncings.Clear();
                bitmapsToWrite.Clear();
                collideables.Clear();
                skipY.Clear();
                visibles.Clear();
                Stopwatch watch = new Stopwatch();
                watch.Start();
                Console.WriteLine("Loading PowerPoint document main.pptx...");
                mainDocument = PresentationDocument.Load(currentProjectFolderPath + "\\PPVerilogEngine\\main.pptx");
                Console.WriteLine("Loaded PowerPoint document main.pptx!");

                using (StreamWriter writer = new StreamWriter(currentProjectFolderPath + "\\IH8Verilog_main.v"))
                {
                    List<string> movs=getMovableVarNames(mainDocument.Slides[0]);
                    List<string> collsNames = getcollsVarNames(mainDocument.Slides[0]);
                    Console.WriteLine("Writing main module definition...");
                    writer.WriteLine("\n//--  This file was automatically generated by the PowerPoint2Verilog compiler. Please do not change anything and use the compiler instead --//\n");
                    writer.WriteLine(("module PP2VerilogDrawingController(CLOCK,reset,animationCLOCK,wasd,arrows,xPixel,yPixel,VGAr,VGAg,VGAb,mouseX,mouseY"+((movs.Count>0)?",":"") + String.Join(",",movs.ToArray())+","+ ((collsNames.Count > 0) ? "," : "") + String.Join(",", collsNames.ToArray())+","+ String.Join(",", skipY.ToArray()) + "," + String.Join(",", visibles.ToArray()) + ");" + Environment.NewLine).Replace(",,",",").Replace(",,", ",").Replace(",,", ","));

                    writer.WriteLine("input CLOCK;");
                    writer.WriteLine("input animationCLOCK;");
                    writer.WriteLine("input [3:0]wasd;");
                    writer.WriteLine("input [3:0]arrows;");
                    writer.WriteLine("input [9:0]xPixel;" + Environment.NewLine + "input[8:0]yPixel;");
                    writer.WriteLine("input [10:0]mouseX;");
                    writer.WriteLine("input [10:0]mouseY;");
                    writer.WriteLine("output [7:0]VGAr;");
                    writer.WriteLine("output [7:0]VGAg;");
                    writer.WriteLine("output [7:0]VGAb;");
                    writer.WriteLine("reg [7:0]VGAr;");
                    writer.WriteLine("reg [7:0]VGAg;");
                    writer.WriteLine("reg [7:0]VGAb;");
                    writer.WriteLine("input reset;");
                    foreach (String s in skipY)
                    {
                        writer.WriteLine("input " + s + ";");
                    }

                    foreach (String s in collsNames)
                    {
                        writer.WriteLine("output " + s + ";");
                    }

                    foreach (String s in movs)
                    {
                        writer.WriteLine("input [9:0]"+s+";");
                    }
                    writer.WriteLine();

                    writer.WriteLine("always @(*)");
                    writer.WriteLine("begin\n");


                    Console.WriteLine("Compiling and writing first slide...");
                    if (mainDocument.Slides.Count > 0) writeSlide(mainDocument.Slides[0], 1, writer);



                    writer.WriteLine("\nend\n");

                    foreach (String s in arrowMovings)
                    {
                        writer.WriteLine("wire [9:0]" + s + ";");
                    }
                    foreach (String s in wasdMovings)
                    {
                        writer.WriteLine("wire [9:0]" + s + ";");
                    }
                    foreach (String s in bouncings)
                    {
                        writer.WriteLine("wire [9:0]" + s + ";");
                    }

                    foreach (String s in skipY)
                    {
                        writer.WriteLine("wire [9:0]" + s + ";");
                    }

                    foreach (String s in visibles)
                    {
                        writer.WriteLine("input " + s + ";");
                    }




                    writer.WriteLine();
                    if (arrowMovings.Count > 0 || wasdMovings.Count > 0||true)
                    {
                        string aaa=("\nanimations anim1(animationCLOCK,reset,wasd,arrows," + String.Join(",", bouncings.ToArray()) + ","+ String.Join(",", arrowMovings.ToArray()) + "," + String.Join(",", wasdMovings.ToArray()) + ");");
                        writer.WriteLine(aaa.Replace(",,",",").Replace(",,", ","));
                    }


                    List<string> varNames = new List<string>();
                    foreach (KeyValuePair<string, List<Collideables>> var in collideables)
                    {
                        varNames.Add("col" + var.Key);
                        foreach (Collideables col in var.Value)
                        {
                            if (col.x.EndsWith("X") || col.x.EndsWith("Y")) varNames.Add(col.x);
                            if (col.y.EndsWith("X") || col.y.EndsWith("Y")) varNames.Add(col.y);
                        }
                    }
                    writer.WriteLine("collsMod mod(" + String.Join(",", varNames) + ");");

                    foreach (MemoryBitmaps m in bitmapsToWrite)
                    {
                        writer.WriteLine("wire [15:0]" + m.name + "q;");
                        writer.WriteLine(String.Format("ram{0} {0}ram((((yPixel-{0}Y+{0}SKIPY)/{2})*{1} +((xPixel-{0}X)/{2})+1),CLOCK,16'd0,0,{0}q);",
                            m.name,m.reducedBitmap.Width,m.scale));


                        Console.WriteLine("\tCreating memory initialization file for: " + m.name+"... ("+m.size+" words)");

                        long count = 0;
                        ulong[] array = new ulong[m.size];
                        for (int j = 0; j < m.reducedBitmap.Height; j++)
                        {
                            for (int i = 0; i < m.reducedBitmap.Width; i++)
                            {
                                System.Drawing.Color color = m.reducedBitmap.GetPixel(i, j);
                                ulong hugeColor = 0;
                                ulong visib = (ulong)(color.A>10?1:0);
                                hugeColor = hugeColor + (visib << 15);
                                ulong rColor = (byte)(color.R / 8);
                                hugeColor = hugeColor + (rColor << 10);
                                ulong gColor = (byte)(color.G / 8);
                                hugeColor = hugeColor + (gColor << 5);
                                ulong bColor = (byte)(color.B / 8);
                                hugeColor = hugeColor + (bColor << 0);
                                array[count] = hugeColor;
                                count += 1;
                            }
                        }

                        using (StreamWriter writer2 = new StreamWriter(new FileInfo(currentProjectFilePath).Directory+ "\\memInitialization\\ram"+m.name+".mif"))
                        {
                            writer2.WriteLine("DEPTH = " + array.Length + ";");
                            writer2.WriteLine("WIDTH = 16;");
                            writer2.WriteLine("ADDRESS_RADIX = DEC;");
                            writer2.WriteLine("DATA_RADIX = DEC;");
                            writer2.WriteLine("CONTENT");
                            writer2.WriteLine("BEGIN ");
                            for (int i = 0; i < array.Length; i++)
                            {
                                writer2.WriteLine(i + ":" + array[i] + ";");
                            }
                            writer2.WriteLine("END;");
                        }
                    }


                    writer.WriteLine(Environment.NewLine + "endmodule");

                    if(arrowMovings.Count>0 || wasdMovings.Count>0 || bouncings.Count > 0||true)
                    {
                        writeAnimationModule(mainDocument.Slides[0],writer);
                    }

                    watch.Stop();
                    Console.WriteLine("Compilation finished. Took {0}s.",watch.ElapsedMilliseconds/1000.0f);

                    writeCollisionModule(writer);
                }


                working = false;
            });

            Task.Run(() => {
                Thread.Sleep(7500);
                this.Invoke((MethodInvoker)delegate () {
                    pictureBox1.Visible = false;
                });

            });
        }

        private List<string> getcollsVarNames(Slide slide)
        {
            List<string> toReturn = new List<string>();

            foreach (Shape shape in slide.Content.Drawings.OfType<Shape>())
            {
                Dictionary<string, string> properties = getProperties(shape.Text);
                if (properties.ContainsKey("COLLIDING"))
                {
                    if(toReturn.Contains("col" + properties["COLLIDING"].Replace(" ", "_")) == false) toReturn.Add("col" + properties["COLLIDING"].Replace(" ", "_"));
                }
            }

            foreach (Picture shape in slide.Content.Drawings.OfType<Picture>())
            {
                Dictionary<string, string> properties = getProperties(null, shape.AlternativeText.Description);
                if (properties.ContainsKey("COLLIDING"))
                {
                    if (toReturn.Contains("col" + properties["COLLIDING"].Replace(" ", "_")) == false) toReturn.Add("col" + properties["COLLIDING"].Replace(" ", "_"));
                }
            }

            return toReturn; ;
        }

        private void writeAnimationModule(Slide slide,StreamWriter writer)
        {
           string aaa=("\nmodule animations(animationCLOCK,reset,wasd,arrows," +  String.Join(",", bouncings.ToArray())+","+ String.Join(",",arrowMovings.ToArray())+","+ String.Join(",", wasdMovings.ToArray()) + ");\n");
            writer.WriteLine(aaa.Replace(",,", ",").Replace(",,", ","));

            writer.WriteLine("input reset;");
            foreach (String s in arrowMovings)
            {
                writer.WriteLine("output [9:0]" + s + ";");
                writer.WriteLine("reg [9:0]" + s + ";");
            }
            foreach (String s in wasdMovings)
            {
                writer.WriteLine("output [9:0]" + s + ";");
                writer.WriteLine("reg [9:0]" + s + ";");
            }
            foreach (String s in bouncings)
            {
                writer.WriteLine("output [9:0]" + s + ";");
                writer.WriteLine("reg [9:0]" + s + ";");
                writer.WriteLine("reg "+s+"Dir;");
            }

            writer.WriteLine("input animationCLOCK;");
            writer.WriteLine("input [3:0]arrows;");
            writer.WriteLine("input [3:0]wasd;");
            writer.WriteLine("reg initilized;");

            writer.WriteLine("\ninitial begin");

            foreach (ResetLocations a in resetLocations)
            {
                writer.WriteLine("\t" + a.varName + "=" + a.defValue + ";");
            }
            writer.WriteLine("end\n");

            writer.WriteLine("\nalways @ (posedge animationCLOCK)");
            writer.WriteLine("begin");


         
            /* foreach (String s in arrowMovings)
             {
                 writer.WriteLine("input [9:0]" + s + ";");

             }*/
            foreach (String s in wasdMovings)
            {
                if (s.EndsWith("X")) writer.WriteLine(getTabs(1)+"//Writing WASD movement for " + s+":");
                MovingProperties properties = movingProperties[s.Substring(0,s.Length-1)];
                if(s.EndsWith("X"))
                {
                    writer.WriteLine(getTabs(1) + "if(wasd[1]==1 && " + s + ">" + properties.minX + ") " + s + "=" + s + "-"+properties.speed+";");
                    writer.WriteLine(getTabs(1) + "if (wasd[3] == 1 && " + s + " < " + properties.maxX + " - " + properties.width + ") " + s + " = " + s + " + " + properties.speed + ";");
                }
                else
                {
                    writer.WriteLine(getTabs(1) + "if(wasd[0]==1 && "+s+ ">" + properties.minY + ") " + s+"="+s+ "-" + properties.speed + ";");
                    writer.WriteLine(getTabs(1) + "if(wasd[2]==1 && " + s + "<" + properties.maxY + "-" + properties.height + ") " + s + "=" + s + "+" + properties.speed + ";");
                }
            }

            writer.WriteLine();

            foreach (String s in arrowMovings)
            {
                if (s.EndsWith("X")) writer.WriteLine(getTabs(1) + "//Writing ARROWS movement for " + s + ":");
                MovingProperties properties = movingProperties[s.Substring(0, s.Length - 1)];
                if (s.EndsWith("X"))
                {
                    writer.WriteLine(getTabs(1) + "if(arrows[1]==1 && " + s + ">" + properties.minX + ") " + s + "=" + s + "-" + properties.speed + ";");
                    writer.WriteLine(getTabs(1) + "if (arrows[3] == 1 && " + s + " < " + properties.maxX + " - " + properties.width + ") " + s + " = " + s + " + " + properties.speed + ";");
                }
                else
                {
                    writer.WriteLine(getTabs(1) + "if(arrows[0]==1 && " + s + ">" + properties.minY + ") " + s + "=" + s + "-" + properties.speed + ";");
                    writer.WriteLine(getTabs(1) + "if(arrows[2]==1 && " + s + "<" + properties.maxY + "-" + properties.height + ") " + s + "=" + s + "+" + properties.speed + ";");
                }
            }

            writer.WriteLine();

            foreach (String s in bouncings)
            {
                if (s.EndsWith("X")) writer.WriteLine(getTabs(1) + "//Writing Bouncing movement for " + s + ":");
                MovingProperties properties = movingProperties[s.Substring(0, s.Length - 1)];
                writer.WriteLine("\tif("+s+"Dir==1)");
                writer.WriteLine("\tbegin");
                if(s.EndsWith("X"))
                {
                    writer.WriteLine("\t\tif (" + s + " >= "+properties.maxX+" - " + properties.width + ")");
                }
                else
                {
                    writer.WriteLine("\t\tif (" + s + " >= " + properties.maxY + " - " + properties.height + ")");
                }
     
                writer.WriteLine("\t\tbegin");
                writer.WriteLine("\t\t\t" + s + "Dir = " + properties.minX+ ";");
                writer.WriteLine("\t\tend");
                writer.WriteLine("\t\telse");
                writer.WriteLine("\t\tbegin");
                writer.WriteLine("\t\t\t" + s + " <= " + s + " + " + properties.speed + ";");
                writer.WriteLine("\t\tend");
                writer.WriteLine("\tend");
                writer.WriteLine("\telse");
                writer.WriteLine("\tbegin");
                writer.WriteLine("\t\tif (" + s + " <= " + properties.minY + ")");
                writer.WriteLine("\t\tbegin");
                writer.WriteLine("\t\t\t" + s + "Dir = 1;");
                writer.WriteLine("\t\tend");
                writer.WriteLine("\t\telse");
                writer.WriteLine("\t\tbegin");
                writer.WriteLine("\t\t\t" + s + " <= " + s + " - " + properties.speed + ";");
                writer.WriteLine("\t\tend");
                writer.WriteLine("\tend");
            }

            writer.WriteLine("end");

            writer.WriteLine("\nendmodule");
        }

        void writeSlide(Slide slide,int tabs,StreamWriter writer)
        {
            Console.WriteLine(getTabs(1) + "Reading properties from slide:");
            Dictionary<string, string> slideProperties=new Dictionary<string, string>();
            if(slide.Notes!=null)
            {
                slideProperties=getProperties(slide.Notes.Content.Drawings.OfType<Shape>().Single(sp => sp.Placeholder.PlaceholderType == PlaceholderType.Text).Text);                
            }

            for(int i=0;i<slideProperties.Values.Count;i++)
            {
                Console.WriteLine(getTabs(2) + slideProperties.Keys.ElementAt(i) + " = " + slideProperties.Values.ElementAt(i));
            }

            //Background color
            System.Drawing.Color backColor = System.Drawing.Color.White;  
            if (slideProperties.ContainsKey("BACKCOLOR"))
            {
                backColor = parseColor(slideProperties["BACKCOLOR"]);                
            }
            

            writer.WriteLine(getTabs(tabs)+"//Writing backgound color");
            writer.WriteLine(getTabs(tabs)+"VGAr = " + formatNumber("b", 8, Convert.ToString(backColor.R, 2).PadLeft(8, '0')) + ";");
            writer.WriteLine(getTabs(tabs)+"VGAg = " + formatNumber("b", 8, Convert.ToString(backColor.G, 2).PadLeft(8, '0')) + "; ");
            writer.WriteLine(getTabs(tabs)+"VGAb = " + formatNumber("b", 8, Convert.ToString(backColor.B, 2).PadLeft(8, '0')) + "; ");

           

            Console.WriteLine(getTabs(1) + "Writing thingys...");
            drawBasicThingys(writer,mainDocument.Slides[0],tabs);
        }

        private void drawBasicThingys(StreamWriter writer, Slide slide, int tabs)
        {
            foreach (GeometryShape picturex in slide.Content.Drawings)
            {
                Dictionary<string, string> properties=new Dictionary<string, string>();
                if (picturex is Picture)
                {
                    properties = getProperties(null, (picturex as Picture).AlternativeText.Description);
                }
                else if (picturex is Shape)
                {
                    properties= getProperties((picturex as Shape).Text); 
                }

                getScaledLayout(picturex.Layout);

                int allowedTransparencyLevel = 0;

                if (picturex is Picture || picturex is Shape)
                {                    
                    if (properties.ContainsKey("TRANSPARENT")) allowedTransparencyLevel = 1;
                    if (properties.ContainsKey("ADVANCEDTRANSPARENT")) allowedTransparencyLevel = 2;

                    int minX = properties.ContainsKey("BOUNDSX") ?int.Parse(properties["BOUNDSX"].Split(',')[0]) : 0;
                    int maxX = properties.ContainsKey("BOUNDSX") ? int.Parse(properties["BOUNDSX"].Split(',')[1]) : 640;
                    int minY = properties.ContainsKey("BOUNDSY") ? int.Parse(properties["BOUNDSY"].Split(',')[0]) : 0;
                    int maxY = properties.ContainsKey("BOUNDSY") ? int.Parse(properties["BOUNDSY"].Split(',')[1]) : 480;

                    if (properties.ContainsKey("WASDMovement") && properties.ContainsKey("NAME") && properties.ContainsKey("MOVEABLE"))
                    {
                        int sp = properties.ContainsKey("AnimationSpeed") ? int.Parse(properties["AnimationSpeed"]) : 1;
                        wasdMovings.Add(properties["NAME"].Replace(" ", "_") + "X");
                        wasdMovings.Add(properties["NAME"].Replace(" ", "_") + "Y");                        
                        movingProperties.Add(properties["NAME"].Replace(" ", "_"), new MovingProperties() { height = (int)picturex.Layout.Height.To(LengthUnit.Point), width = (int)picturex.Layout.Width.To(LengthUnit.Point), name = properties["NAME"].Replace(" ", "_"), speed = sp,minX=minX,maxX=maxX,maxY=maxY,minY=minY });


                    }

                    if (properties.ContainsKey("ARROWSMovement") && properties.ContainsKey("NAME") && properties.ContainsKey("MOVEABLE"))
                    {
                        int sp = properties.ContainsKey("AnimationSpeed") ? int.Parse(properties["AnimationSpeed"]) : 1;
                        arrowMovings.Add(properties["NAME"].Replace(" ", "_") + "X");
                        arrowMovings.Add(properties["NAME"].Replace(" ", "_") + "Y");
                        movingProperties.Add(properties["NAME"].Replace(" ", "_"), new MovingProperties() { height = (int)picturex.Layout.Height.To(LengthUnit.Point), width = (int)picturex.Layout.Width.To(LengthUnit.Point), name = properties["NAME"].Replace(" ", "_"), speed = sp, minX = minX, maxX = maxX, maxY = maxY, minY = minY });
                    }

                    if (properties.ContainsKey("BOUNCING") && properties.ContainsKey("NAME") && properties.ContainsKey("MOVEABLE"))
                    {
                        int sp = properties.ContainsKey("AnimationSpeed") ? int.Parse(properties["AnimationSpeed"]) : 1;
                        bouncings.Add(properties["NAME"].Replace(" ", "_") + "X");
                        bouncings.Add(properties["NAME"].Replace(" ", "_") + "Y");
                        movingProperties.Add(properties["NAME"].Replace(" ", "_"), new MovingProperties() { height = (int)picturex.Layout.Height.To(LengthUnit.Point), width = (int)picturex.Layout.Width.To(LengthUnit.Point), name = properties["NAME"].Replace(" ", "_"), speed = sp, minX = minX, maxX = maxX, maxY = maxY, minY = minY });
                    }

                    if(properties.ContainsKey("MOVEABLE") && (properties.ContainsKey("ARROWSMovement") || properties.ContainsKey("BOUNCING") || properties.ContainsKey("WASDMovement")))
                    {
                        resetLocations.Add(new ResetLocations() { varName = properties["NAME"].Replace(" ", "_") + "X", defValue = (int)picturex.Layout.Left.To(LengthUnit.Point) });
                        resetLocations.Add(new ResetLocations() { varName = properties["NAME"].Replace(" ", "_") + "Y", defValue = (int)picturex.Layout.Top.To(LengthUnit.Point) });
                    }

                }

                if(properties.ContainsKey("COLLIDING"))
                {
                    Collideables collideablesx = new Collideables();
                    collideablesx.width = (int)picturex.Layout.Width.To(LengthUnit.Point);
                    collideablesx.height = (int)picturex.Layout.Height.To(LengthUnit.Point);
                    if(properties.ContainsKey("MOVEABLE"))
                    {
                        collideablesx.x = properties["NAME"].Replace(" ", "_") + "X";
                        collideablesx.y = properties["NAME"].Replace(" ", "_") + "Y";
                    }
                    else
                    {
                        collideablesx.x = ((int)picturex.Layout.Left.To(LengthUnit.Point)).ToString();
                        collideablesx.y = ((int)picturex.Layout.Top.To(LengthUnit.Point)).ToString();
                    }

                    if (collideables.ContainsKey(properties["COLLIDING"]) == false)
                    {
                        collideables.Add(properties["COLLIDING"], new List<Collideables>());
                    }

                    if (collideables.ContainsKey(properties["COLLIDING"]) == false)
                    {
                        collideables.Add(properties["COLLIDING"], new List<Collideables>());
                    }

                    collideables[properties["COLLIDING"]].Add(collideablesx);


                }
                


                if (picturex is Picture)
                {
                    Picture picture = (Picture)picturex;
                    if (picture.DrawingType == DrawingType.Picture)
                    {
                        Console.WriteLine(getTabs(2) + "Writing picture: " + (properties.ContainsKey("NAME") ? properties["NAME"] : (properties.ContainsKey("CURSOR") ? "Mouse" : "UNNAMED")));
                        //Transparency only valid for in-memory pictures;

                        int compresionFactor = 1;
                        int maxColorBits = 8;
                        if (properties.ContainsKey("COMPRESIONLEVEL")) compresionFactor = int.Parse(properties["COMPRESIONLEVEL"]);
                        if (properties.ContainsKey("COLORBITS")) maxColorBits = int.Parse(properties["COLORBITS"]);

                        Bitmap baseBitmap = new Bitmap(picture.Fill.Data.Content.Open());
                        if (Directory.Exists(currentProjectFolderPath + "/PPVerilogEngine//tempPictures") == false) Directory.CreateDirectory(currentProjectFolderPath + "/PPVerilogEngine//tempPictures");
                        baseBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//basePicture.png");
                        

                        if (properties.ContainsKey("MEMORY"))
                        {
                            Bitmap resizedBitmap = new Bitmap(baseBitmap, new Size((int)(picture.Layout.Width / compresionFactor), (int)(picture.Layout.Height / compresionFactor)));
                            resizedBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//memcompressedPicture.png");
                            maxColorBits = 5;
                            Bitmap colorSetBitmap = new Bitmap(resizedBitmap);
                            colorSetBitmap = limitColorBitmap(colorSetBitmap, maxColorBits);
                            colorSetBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//memcolorLimitedPicture.png");
                            MemoryBitmaps memoryBitmaps = new MemoryBitmaps() { reducedBitmap = colorSetBitmap };
                            if (properties.ContainsKey("MOVEABLE") && properties.ContainsKey("NAME"))
                            {
                                memoryBitmaps.x = properties["NAME"].Replace(" ", "_") + "X";
                                memoryBitmaps.y = properties["NAME"].Replace(" ", "_") + "Y";
                            }
                            else
                            {
                                memoryBitmaps.x = ((int)(picture.Layout.Left.To(LengthUnit.Point))).ToString();
                                memoryBitmaps.y = ((int)(picture.Layout.Top.To(LengthUnit.Point))).ToString();
                            }
                            memoryBitmaps.name = properties["NAME"].Replace(" ", "_");
                            memoryBitmaps.scale = compresionFactor;

                            memoryBitmaps.size = memoryBitmaps.reducedBitmap.Width * memoryBitmaps.reducedBitmap.Height;
                            bitmapsToWrite.Add(memoryBitmaps);
                            writer.WriteLine();

                            string extraaaaaa = "";
                            if(properties.ContainsKey("VISIBLE"))
                            {
                                extraaaaaa = "{0}VISIBLE && ";
                            }

                            if(properties.ContainsKey("SKIPY"))
                            {
                                writer.WriteLine(getTabs(tabs) + String.Format("if("+extraaaaaa+"yPixel>={0}Y && yPixel<{0}Y+({2}*{1})-{4}SKIPY && xPixel>={0}X+1 && xPixel<{0}X+({3}*{1}) && {0}q[15]==1'b1)", properties["NAME"].Replace(" ", "_"), compresionFactor, (int)(picture.Layout.Height / compresionFactor), (int)(picture.Layout.Width / compresionFactor),properties["NAME"]));

                            }
                            else
                            {
                                writer.WriteLine(getTabs(tabs) + String.Format("if(" + extraaaaaa + "yPixel>={0}Y && yPixel<{0}Y+({2}*{1}) && xPixel>={0}X+1 && xPixel<{0}X+({3}*{1}) && {0}q[15]==1'b1)", properties["NAME"].Replace(" ", "_"), compresionFactor, (int)(picture.Layout.Height / compresionFactor), (int)(picture.Layout.Width / compresionFactor)));

                            }
                            writer.WriteLine("\tbegin");


                            if (allowedTransparencyLevel == 0)  //No transparency allowed
                            {
                                writer.WriteLine(getTabs(1 + tabs) + "VGAr=" + properties["NAME"].Replace(" ", "_") + "q[14:10]*8;");
                                writer.WriteLine(getTabs(1 + tabs) + "VGAg=" + properties["NAME"].Replace(" ", "_") + "q[9:5]*8;");
                                writer.WriteLine(getTabs(1 + tabs) + "VGAb=" + properties["NAME"].Replace(" ", "_") + "q[4:0]*8;");
                            }
                            else
                            {
                                if (allowedTransparencyLevel == 1)  //Basic transparency (50/50) allowed
                                {
                                    writer.WriteLine(getTabs(1 + tabs) + "VGAr=(VGAr+" + properties["NAME"].Replace(" ", "_") + "q[14:10]*8)/2;");
                                    writer.WriteLine(getTabs(1 + tabs) + "VGAg=(VGAg+" + properties["NAME"].Replace(" ", "_") + "q[9:5]*8)/2;");
                                    writer.WriteLine(getTabs(1 + tabs) + "VGAb=(VGAb+" + properties["NAME"].Replace(" ", "_") + "q[4:0]*8)/2;");
                                }
                                else  //Custom color based trnasparency allowed
                                {
                                    int transLevel = int.Parse(properties["ADVANCEDTRANSPARENT"]);
                                    writer.WriteLine(getTabs(tabs + 1) + "VGAr = (" + "(" + memoryBitmaps.name + "q[14:10]*8) *" + (100 - transLevel) + "+" + transLevel + " * VGAr) / 100;");
                                    writer.WriteLine(getTabs(tabs + 1) + "VGAg= (" + "(" + memoryBitmaps.name + "q[9:5]*8) *" + (100 - transLevel) + "+" + transLevel + " * VGAg) / 100;");
                                    writer.WriteLine(getTabs(tabs + 1) + "VGAb = (" + "(" + memoryBitmaps.name + "q[4:0]*8) *" + (100 - transLevel) + "+" + transLevel + " * VGAb) / 100;");
                                }
                            }

                            


                            writer.WriteLine("\tend");




                            Console.WriteLine(getTabs(3) + "Picture from memory: " + (properties.ContainsKey("NAME") ? properties["NAME"] : "UNNAMED"));
                        }
                        else if (properties.ContainsKey("CURSOR"))
                        {
                            Size size = new Size(10, 10);
                            if (properties.ContainsKey("CURSOR-SIZE")) size = new Size(int.Parse(properties["CURSOR-SIZE"].Split(',')[0]), int.Parse(properties["CURSOR-SIZE"].Split(',')[1]));

                            Bitmap resizedBitmap = new Bitmap(baseBitmap, size);
                            resizedBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//compressedPicture.png");

                            Bitmap colorSetBitmap = new Bitmap(resizedBitmap);
                            colorSetBitmap = limitColorBitmap(colorSetBitmap, maxColorBits);
                            colorSetBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//colorLimitedPicture.png");

                            int savedPixels = 0;
                            int usedPixels = 0;
                            writer.WriteLine(Environment.NewLine + getTabs(tabs) + "//Drawing mouse: ");
                            for (int i = 0; i < colorSetBitmap.Height; i++)
                            {
                                int startingPixel = -1;
                                var startingColor = System.Drawing.Color.White;
                                for (int j = 0; j < colorSetBitmap.Width; j++)
                                {
                                    System.Drawing.Color color = colorSetBitmap.GetPixel(j, i);
                                    if (color.A > 100)
                                    {
                                        if (startingPixel == -1)
                                        {
                                            startingPixel = j;
                                            startingColor = color;
                                        }
                                        else
                                        {
                                            if ((color.R != startingColor.R || color.G != startingColor.G || color.B != startingColor.B) || j == colorSetBitmap.Width - 1) //Not the same, write the old one  || From startingPixel to current-1 in width (j)
                                            {
                                                writer.Write(getTabs(tabs) + "if(yPixel>=(mouseY+" + (int)((i * compresionFactor)) + ") && yPixel<(mouseY+" + (int)(((i + 1) * compresionFactor)) + ") && xPixel>=(mouseX+" + (int)((startingPixel * compresionFactor)) + ") && xPixel<(mouseX+" + (int)((j * compresionFactor)) + ")) ");

                                                writer.WriteLine("{VGAr,VGAg,VGAb}={" + formatNumber("b", 8, Convert.ToString(startingColor.R, 2).PadLeft(8, '0')) + "," + formatNumber("b", 8, Convert.ToString(startingColor.G, 2).PadLeft(8, '0')) + "," + formatNumber("b", 8, Convert.ToString(startingColor.B, 2).PadLeft(8, '0')) + "};");

                                                startingColor = color;
                                                startingPixel = j;
                                                usedPixels++;
                                            }
                                            else
                                            {
                                                savedPixels++;
                                                //Do nothing, is still the same color, keep waiting until it changes.
                                            }
                                        }
                                    }
                                }
                            }

                            Console.WriteLine(getTabs(3) + "Mouse drawn at " + Math.Round((float)usedPixels / (baseBitmap.Width * baseBitmap.Height) * 100, 2) + "% of the original size!");

                        }
                        else
                        {
                            Bitmap resizedBitmap = new Bitmap(baseBitmap, new Size((int)(picture.Layout.Width / compresionFactor), (int)(picture.Layout.Height / compresionFactor)));
                            resizedBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//compressedPicture.png");

                            Bitmap colorSetBitmap = new Bitmap(resizedBitmap);
                            colorSetBitmap = limitColorBitmap(colorSetBitmap, maxColorBits);
                            colorSetBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//colorLimitedPicture.png");

                            int savedPixels = 0;
                            int usedPixels = 0;
                            writer.WriteLine(Environment.NewLine + getTabs(tabs) + "//Drawing picture with compression rate: " + compresionFactor + ":1");
                            for (int i = 0; i < colorSetBitmap.Height; i++)
                            {
                                int startingPixel = -1;
                                var startingColor = System.Drawing.Color.White;
                                for (int j = 0; j < colorSetBitmap.Width; j++)
                                {
                                    System.Drawing.Color color = colorSetBitmap.GetPixel(j, i);
                                    if (color.A > 100)
                                    {
                                        if (startingPixel == -1)
                                        {
                                            startingPixel = j;
                                            startingColor = color;
                                        }
                                        else
                                        {
                                            if ((color.R != startingColor.R || color.G != startingColor.G || color.B != startingColor.B) || j == colorSetBitmap.Width - 1) //Not the same, write the old one  || From startingPixel to current-1 in width (j)
                                            {

                                                writer.Write(getTabs(tabs) + "if(yPixel>=" + (int)(picture.Layout.Top + (i * compresionFactor)) + " && yPixel<" + (int)(picture.Layout.Top + ((i + 1) * compresionFactor)) + " && xPixel>=" + (int)(picture.Layout.Left + (startingPixel * compresionFactor)) + " && xPixel<" + (int)(picture.Layout.Left + (j * compresionFactor)) + ") ");
                                                writer.WriteLine("{VGAr,VGAg,VGAb}={" + formatNumber("b", 8, Convert.ToString(startingColor.R, 2).PadLeft(8, '0')) + "," + formatNumber("b", 8, Convert.ToString(startingColor.G, 2).PadLeft(8, '0')) + "," + formatNumber("b", 8, Convert.ToString(startingColor.B, 2).PadLeft(8, '0')) + "};");



                                                startingColor = color;
                                                startingPixel = j;
                                                usedPixels++;
                                            }
                                            else
                                            {
                                                savedPixels++;
                                                //Do nothing, is still the same color, keep waiting until it changes.
                                            }
                                        }
                                    }
                                }
                            }

                            Console.WriteLine(getTabs(3) + "Picture compressed at " + Math.Round((float)usedPixels / (baseBitmap.Width * baseBitmap.Height) * 100, 2) + "% of the original size!");
                        }

                    }
                }
                else if (picturex is Shape)
                {
                    Shape shape = (Shape)picturex;

                    if (shape.Format.Fill.FillType == FillFormatType.Solid)
                    {
                        SolidFillFormat f = (SolidFillFormat)shape.Format.Fill;

                        //Find level of transparency                       

                        if (shape.ShapeType == ShapeGeometryType.Rectangle)
                        {
                            Console.WriteLine(getTabs(2) + "Writing solid shape: " + (properties.ContainsKey("NAME") ? properties["NAME"] : "UNNAMED"));


                            writer.WriteLine(Environment.NewLine + getTabs(tabs) + "//Drawing Solid shape \"" + (properties.ContainsKey("NAME") ? properties["NAME"] : "UNNAMED") + "\"");
                            if (properties.ContainsKey("TRANSPARENT")) writer.WriteLine(getTabs(tabs) + "//   --> Allowed 50% transparent render");
                            if (properties.ContainsKey("ADVANCEDTRANSPARENT")) writer.WriteLine(getTabs(tabs) + "//   --> Allowed advanced transparent render");

                           

                            //Draw shapes
                            if (properties.ContainsKey("MOVEABLE") && properties.ContainsKey("NAME"))
                            {
                                writeSquareShapeColorMoveable(writer, f.Color, shape.Layout, tabs, shape.Format.Outline, properties.ContainsKey("BORDER"), allowedTransparencyLevel, properties["NAME"].Replace(" ", "_"));
                            }
                            else
                            {
                                writeSquareShapeColor(writer, f.Color, shape.Layout, tabs, shape.Format.Outline, properties.ContainsKey("BORDER"), allowedTransparencyLevel);
                            }
                           

                        }
                    }


                }
            }
        }

        private Dictionary<string, string> getProperties(GemBox.Presentation.TextBox notes,string fromString="")
        {
            Dictionary<string, string> toReturn = new Dictionary<string, string>();
            string finalNotes = "";
            if (fromString=="")
            {
                if (notes == null) return toReturn;
                
                foreach (var line in notes.Paragraphs)
                {
                    foreach (var text in line.Elements)
                    {
                        string property = text.ToString();
                        finalNotes += property;

                    }
                }
            }else
            {
                finalNotes = fromString;
            }

            finalNotes = finalNotes.Replace("\n", "");

            List<string> properties = new List<string>();
            if(finalNotes.Contains(";"))
            {
                properties = finalNotes.Split(';').ToList();
            }
            else
            {
                properties.Add(finalNotes);
            }

            foreach (string propertyx in properties)
            {
                string property = propertyx;
                if (property.Contains("[") && property.Contains("]") && property.StartsWith("//") == false)
                {
                    property = property.Replace("[", "").Replace("]", "");
                    if (property.Contains("="))
                    {
                        toReturn.Add(property.Split('=')[0].Replace(" ",""), property.Split('=')[1].Replace(" ", ""));
                    }
                    else
                    {
                        toReturn.Add(property.Replace(" ", ""), "");
                    }
                   // Console.WriteLine("Property found: " + property);
                }
            }



            return toReturn;
        }

     

        private Bitmap limitColorBitmap(Bitmap colorSetBitmap,int bitLimit)
        {
            int dividend = (int)(256 / (Math.Pow(2,bitLimit-1)));

            for(int i=0;i<colorSetBitmap.Width;i++)
            {
                for(int j=0;j<colorSetBitmap.Height;j++)
                {
                    System.Drawing.Color color = colorSetBitmap.GetPixel(i, j);
                    int r = (int)(Math.Round((double)color.R / dividend, 0) * dividend);
                    int g = (int)(Math.Round((double)color.G / dividend, 0) * dividend);
                    int b = (int)(Math.Round((double)color.B / dividend, 0) * dividend);
                    if (r > 255) r = 255;
                    if (g > 255) g = 255;
                    if (b > 255) b = 255;
                    color = System.Drawing.Color.FromArgb(color.A,r,g ,b);
                    colorSetBitmap.SetPixel(i,j,color);
                }
            }

            return colorSetBitmap;
        }

        System.Drawing.Color parseColor(string colorString)
        {
            try
            {
                if (colorString.StartsWith("#"))
                {
                    return System.Drawing.Color.FromArgb(255, 255, 255);
                }
                else
                {
                    return System.Drawing.Color.FromArgb(int.Parse(colorString.Split(',')[0]), int.Parse(colorString.Split(',')[1]), int.Parse(colorString.Split(',')[2]));
                }
            }catch(Exception ex)
            {
                Console.WriteLine("An error has occurred when parsing color {0}. {1}", colorString, ex.Message);
                return System.Drawing.Color.White;
            }
           
        }

        string getTabs(int number)
        {
            string toReturn="";

            for (int i = 0; i < number; i++) toReturn += "\t";

            return toReturn;
        }

        DrawingLayout getScaledLayout(DrawingLayout layout)
        {         
            layout.Left = ((layout.Left / 72.0) / 10) * 640;
            layout.Width = ((layout.Width / 72.0) / 10) * 640;
            layout.Top = ((layout.Top / 72.0) / 7.5) * 480;
            layout.Height = ((layout.Height / 72.0) / 7.5) * 480;
            return layout;


        }

       
        public List<string> getMovableVarNames(Slide slide)
        {
            List<string> toReturn = new List<string>();

            foreach (Shape shape in slide.Content.Drawings.OfType<Shape>())
            {
                Dictionary<string, string> properties = getProperties(shape.Text);
                if(properties.ContainsKey("MOVEABLE") && properties.ContainsKey("NAME") && properties.ContainsKey("WASDMovement")==false && properties.ContainsKey("ARROWSMovement")==false &&   properties.ContainsKey("BOUNCING") == false)
                {
                    toReturn.Add(properties["NAME"].Replace(" ","_") + "X");
                    toReturn.Add(properties["NAME"].Replace(" ", "_") + "Y");
                }
                if (properties.ContainsKey("SKIPY") && properties.ContainsKey("NAME"))
                {
                    skipY.Add(properties["NAME"].Replace(" ", "_")+"SKIPY");
                }
                if (properties.ContainsKey("VISIBLE") && properties.ContainsKey("NAME"))
                {
                    skipY.Add(properties["NAME"].Replace(" ", "_") + "VISIBLE");
                }
            }

            foreach (Picture shape in slide.Content.Drawings.OfType<Picture>())
            {
                Dictionary<string, string> properties = getProperties(null,shape.AlternativeText.Description);
                if (properties.ContainsKey("MOVEABLE") && properties.ContainsKey("NAME") && properties.ContainsKey("WASDMovement") == false && properties.ContainsKey("ARROWSMovement") == false && properties.ContainsKey("BOUNCING") == false)
                {
                    toReturn.Add(properties["NAME"].Replace(" ", "_") + "X");
                    toReturn.Add(properties["NAME"].Replace(" ", "_") + "Y");
                }
                if (properties.ContainsKey("SKIPY") && properties.ContainsKey("NAME"))
                {
                    skipY.Add(properties["NAME"].Replace(" ", "_") + "SKIPY");
                }
                if (properties.ContainsKey("VISIBLE") && properties.ContainsKey("NAME"))
                {
                    skipY.Add(properties["NAME"].Replace(" ", "_") + "VISIBLE");
                }
            }

            return toReturn;
        }


        void writeSquareShapeColor(StreamWriter writer, GemBox.Presentation.Color color,DrawingLayout scaledLayout,int tabs,LineFormat outline,bool borderEnabled, int allowedTransparencyLevel)
        {
            writer.WriteLine(getTabs(tabs) + "if(xPixel>=" + (int)scaledLayout.Left.To(LengthUnit.Point) + " && xPixel<=" + ((int)scaledLayout.Left.To(LengthUnit.Point) + (int)scaledLayout.Width.To(LengthUnit.Point)) +
                " && yPixel>=" + (int)scaledLayout.Top.To(LengthUnit.Point) + " && yPixel<=" + ((int)scaledLayout.Top.To(LengthUnit.Point) + (int)scaledLayout.Height.To(LengthUnit.Point)) + ")"+Environment.NewLine+getTabs(tabs)+"begin");

            if(allowedTransparencyLevel == 0 || color.A==255)  //No transparency allowed
            {
                writer.WriteLine(getTabs(tabs + 1) + "VGAr = " + formatNumber("b", 8, Convert.ToString(color.R, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAg = " + formatNumber("b", 8, Convert.ToString(color.G, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAb = " + formatNumber("b", 8, Convert.ToString(color.B, 2).PadLeft(8, '0')) + ";");
            }
            else
            { 
                if(allowedTransparencyLevel == 1 || color.A > 125 && color.A < 130)  //Basic transparency (50/50) allowed
                {
                    writer.WriteLine(getTabs(tabs + 1) + "VGAr = (" + formatNumber("b", 8, Convert.ToString(color.R, 2).PadLeft(8, '0')) + " + VGAr) / 2;");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAg = (" + formatNumber("b", 8, Convert.ToString(color.G, 2).PadLeft(8, '0')) + " + VGAg) / 2;");  
                    writer.WriteLine(getTabs(tabs + 1) + "VGAb = (" + formatNumber("b", 8, Convert.ToString(color.B, 2).PadLeft(8, '0')) + " + VGAb) / 2;");
                }
                else  //Custom color based trnasparency allowed
                {
                    writer.WriteLine(getTabs(tabs + 1) + "VGAr = (" + formatNumber("b", 8, Convert.ToString((int)(color.R*(color.A/255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100)+" * VGAr) / 100));");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAg = (" + formatNumber("b", 8, Convert.ToString((int)(color.G*(color.A / 255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100) + " * VGAg) / 100));");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAb = (" + formatNumber("b", 8, Convert.ToString((int)(color.B * (color.A / 255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100) + " * VGAb) / 100));");
                }
            }

            if(borderEnabled)
            {
                writer.Write(getTabs(tabs + 1) + "if(xPixel<" + Math.Round((int)scaledLayout.Left.To(LengthUnit.Point) + 0.668f * (int)outline.Width.To(LengthUnit.Point),0) + " || " +
                   "xPixel>" + Math.Round((int)scaledLayout.Left.To(LengthUnit.Point) + (int)scaledLayout.Width.To(LengthUnit.Point) - 0.668f * (int)outline.Width.To(LengthUnit.Point),0) + " || "+
                    "yPixel<" + Math.Round((int)scaledLayout.Top.To(LengthUnit.Point) + 0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + " || " +
                   "yPixel>" + Math.Round((int)scaledLayout.Top.To(LengthUnit.Point) + (int)scaledLayout.Height.To(LengthUnit.Point) - 0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + ")");
                writer.WriteLine("    //Drawing border");

                
                writer.WriteLine(getTabs(tabs + 1) + "begin");

                SolidFillFormat outlineFill = (SolidFillFormat)outline.Fill;

                if (allowedTransparencyLevel == 0f || outlineFill.Color.A==255)
                {
                    writer.WriteLine(getTabs(tabs + 2) + "VGAr = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.R, 2).PadLeft(8, '0')) + ";");
                    writer.WriteLine(getTabs(tabs + 2) + "VGAg = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.G, 2).PadLeft(8, '0')) + ";");
                    writer.WriteLine(getTabs(tabs + 2) + "VGAb = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.B, 2).PadLeft(8, '0')) + ";");
                }
                else
                {
                    if (allowedTransparencyLevel==1 || outlineFill.Color.A > 125 && outlineFill.Color.A < 130)
                    {
                        writer.WriteLine(getTabs(tabs + 2) + "VGAr = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.R, 2).PadLeft(8, '0')) + " + VGAr) / 2;");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAg = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.G, 2).PadLeft(8, '0')) + " + VGAg) / 2;");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAb = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.B, 2).PadLeft(8, '0')) + " + VGAb) / 2;");
                    }
                    else
                    {
                        writer.WriteLine(getTabs(tabs + 2) + "VGAr = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.R * (outlineFill.Color.A/100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAr) / 100));");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAg = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.G * (outlineFill.Color.A / 100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAg) / 100));");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAb = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.B * (outlineFill.Color.A / 100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAb) / 100));");

                    }
                }

                writer.WriteLine(getTabs(tabs + 1) + "end");
            }

            writer.WriteLine(getTabs(tabs) + "end");
        }


        void writeSquareShapeColorMoveable(StreamWriter writer, GemBox.Presentation.Color color, DrawingLayout scaledLayout, int tabs, LineFormat outline, bool borderEnabled, int allowedTransparencyLevel,string name)
        {

            writer.WriteLine(getTabs(tabs) + "if(xPixel>="+name+"X && xPixel<="+name+"X+" + (int)scaledLayout.Width.To(LengthUnit.Point) +
                " && yPixel>="+name+"Y && yPixel<="+name+"Y+" + (int)scaledLayout.Height.To(LengthUnit.Point) + ")" + Environment.NewLine + getTabs(tabs) + "begin");

            if (allowedTransparencyLevel == 0 || color.A == 255)  //No transparency allowed
            {
                writer.WriteLine(getTabs(tabs + 1) + "VGAr = " + formatNumber("b", 8, Convert.ToString(color.R, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAg = " + formatNumber("b", 8, Convert.ToString(color.G, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAb = " + formatNumber("b", 8, Convert.ToString(color.B, 2).PadLeft(8, '0')) + ";");
            }
            else
            {
                if (allowedTransparencyLevel == 1 || color.A > 125 && color.A < 130)  //Basic transparency (50/50) allowed
                {
                    writer.WriteLine(getTabs(tabs + 1) + "VGAr = (" + formatNumber("b", 8, Convert.ToString(color.R, 2).PadLeft(8, '0')) + " + VGAr) / 2;");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAg = (" + formatNumber("b", 8, Convert.ToString(color.G, 2).PadLeft(8, '0')) + " + VGAg) / 2;");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAb = (" + formatNumber("b", 8, Convert.ToString(color.B, 2).PadLeft(8, '0')) + " + VGAb) / 2;");
                }
                else  //Custom color based trnasparency allowed
                {
                    writer.WriteLine(getTabs(tabs + 1) + "VGAr = (" + formatNumber("b", 8, Convert.ToString((int)(color.R * (color.A / 255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100) + " * VGAr) / 100));");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAg = (" + formatNumber("b", 8, Convert.ToString((int)(color.G * (color.A / 255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100) + " * VGAg) / 100));");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAb = (" + formatNumber("b", 8, Convert.ToString((int)(color.B * (color.A / 255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100) + " * VGAb) / 100));");
                }
            }

            if (borderEnabled)
            {
                writer.Write(getTabs(tabs + 1) + "if(xPixel<" + name + "X+" + Math.Round(0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + " || " +
                   "xPixel>" + name + "X+" + Math.Round((int)scaledLayout.Width.To(LengthUnit.Point) - 0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + " || " +
                    "yPixel<" + name + "Y+" + Math.Round(0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + " || " +
                   "yPixel>" + name + "Y+" + Math.Round((int)scaledLayout.Height.To(LengthUnit.Point) - 0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + ")");
                writer.WriteLine("    //Drawing border");


                writer.WriteLine(getTabs(tabs + 1) + "begin");

                SolidFillFormat outlineFill = (SolidFillFormat)outline.Fill;

                if (allowedTransparencyLevel == 0f || outlineFill.Color.A == 255)
                {
                    writer.WriteLine(getTabs(tabs + 2) + "VGAr = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.R, 2).PadLeft(8, '0')) + ";");
                    writer.WriteLine(getTabs(tabs + 2) + "VGAg = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.G, 2).PadLeft(8, '0')) + ";");
                    writer.WriteLine(getTabs(tabs + 2) + "VGAb = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.B, 2).PadLeft(8, '0')) + ";");
                }
                else
                {
                    if (allowedTransparencyLevel == 1 || outlineFill.Color.A > 125 && outlineFill.Color.A < 130)
                    {
                        writer.WriteLine(getTabs(tabs + 2) + "VGAr = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.R, 2).PadLeft(8, '0')) + " + VGAr) / 2;");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAg = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.G, 2).PadLeft(8, '0')) + " + VGAg) / 2;");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAb = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.B, 2).PadLeft(8, '0')) + " + VGAb) / 2;");
                    }
                    else
                    {
                        writer.WriteLine(getTabs(tabs + 2) + "VGAr = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.R * (outlineFill.Color.A / 100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAr) / 100));");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAg = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.G * (outlineFill.Color.A / 100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAg) / 100));");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAb = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.B * (outlineFill.Color.A / 100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAb) / 100));");

                    }
                }

                writer.WriteLine(getTabs(tabs + 1) + "end");
            }

            writer.WriteLine(getTabs(tabs) + "end");
        }


        void writeMouse(StreamWriter writer, GemBox.Presentation.Color color, int tabs,Size size)
        {

            writer.WriteLine("\n" + getTabs(tabs) + "//Drawing the mouse");
            writer.WriteLine(getTabs(tabs) + "if(xPixel>mouseX && xPixel<(mouseX+"+size.Width+") && yPixel>mouseY && yPixel<(mouseY+"+size.Height+"))" + Environment.NewLine + getTabs(tabs) + "begin");

           
                writer.WriteLine(getTabs(tabs + 1) + "VGAr = " + formatNumber("b", 8, Convert.ToString(color.R, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAg = " + formatNumber("b", 8, Convert.ToString(color.G, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAb = " + formatNumber("b", 8, Convert.ToString(color.B, 2).PadLeft(8, '0')) + ";");            
            

            writer.WriteLine(getTabs(tabs) + "end");
        }

        string formatNumber(string type,int length,string value)
        {
            return String.Format("{0}'{1}{2}",length,type,value);
        }

   
        private void saveProjectToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if(currentProjectFilePath=="")
            {
                if(saveFileDialog1.ShowDialog()==DialogResult.OK)
                {
                    currentProjectFilePath = saveFileDialog1.FileName;
                    currentProjectFolderPath = new FileInfo(currentProjectFilePath).Directory.FullName;
                }
            }

            if(currentProjectFilePath!="")
            {
                using (StreamWriter writer = new StreamWriter(currentProjectFilePath))
                {
                    if (textBoxProjectName.Text == "") textBoxProjectName.Text = Interaction.InputBox("Project name:", "Project name",new FileInfo(currentProjectFilePath).Directory.Name);
                    writer.WriteLine(textBoxProjectName.Text);
                    writer.WriteLine(checkBoxAutoCompile.Checked.ToString());
                }
            }
        }

        private void openProjectToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                currentProjectFilePath = openFileDialog1.FileName;
                currentProjectFolderPath = new FileInfo(currentProjectFilePath).Directory.FullName;
                using (StreamReader reader = new StreamReader(currentProjectFilePath))
                {
                    textBoxProjectName.Text = reader.ReadLine();
                    checkBoxAutoCompile.Checked = bool.Parse(reader.ReadLine());
                }
            }

            watcher = new FileSystemWatcher();
            watcher.Path = currentProjectFolderPath+ "/PPVerilogEngine";
            watcher.NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite
               | NotifyFilters.FileName | NotifyFilters.DirectoryName;
            watcher.Filter = "*.pptx";

            // Add event handlers.
            watcher.Changed += new FileSystemEventHandler(OnChanged);
            watcher.Created += new FileSystemEventHandler(OnChanged);
            watcher.Deleted += new FileSystemEventHandler(OnChanged);
            watcher.Renamed += new RenamedEventHandler(OnChanged);

            // Begin watching.
            watcher.EnableRaisingEvents = true;
        }

        public void writeCollisionModule(StreamWriter writer)
        {
            List<string> varNames=new List<string>();
            foreach(KeyValuePair<string,List<Collideables>> var in collideables)
            {
                varNames.Add("col"+var.Key);
                foreach(Collideables col in var.Value)
                {
                    if (col.x.EndsWith("X") || col.x.EndsWith("Y")) varNames.Add(col.x);
                    if (col.y.EndsWith("X") || col.y.EndsWith("Y")) varNames.Add(col.y);
                }
            }
            writer.WriteLine("module collsMod(" + String.Join(",",varNames)+");");

            foreach(var a in varNames)
            {
                writer.WriteLine("\t"+((a.StartsWith("col"))?"output ": "input [9:0]") + a+";");         
             
            }

            foreach (KeyValuePair<string, List<Collideables>> var in collideables)
            {
                List<string> statements = new List<string>();
                List<string> usedOnes = new List<string>();

                for(int i=0;i< var.Value.Count;i++)
                {
                    for (int j= 0; j < var.Value.Count; j++)
                    {
                        if(i !=j && usedOnes.Contains(i+" "+j)==false && usedOnes.Contains(j + " " + i) == false)
                        {
                            statements.Add("((" + var.Value[i].y + "+" + var.Value[i].height + ">" + var.Value[j].y + ") && " + "(" + var.Value[i].y + "<" + var.Value[j].y + "+" + var.Value[j].height + ") && " + "(" + var.Value[i].x + "+" + var.Value[i].width + ">" + var.Value[j].x + ") && " + "(" + var.Value[i].x + "<" + var.Value[j].x + "+" + var.Value[j].width + "))");
                            usedOnes.Add(i + " " + j);
                        }
                    }
                }

                writer.WriteLine("\tassign col" + var.Key + "=" + String.Join("||",statements.ToArray())+ ";");


            }


            writer.WriteLine("endmodule");
        }

        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            if(checkBoxAutoCompile.Checked)this.Invoke((MethodInvoker)delegate(){ button1.PerformClick(); });
        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }

        private void button2_Click(object sender, EventArgs e)
        {
            SerialPortCom portCom = new SerialPortCom();
            portCom.Show();
        }
    }

    internal class Collideables
    {
        public string x;
        public string y;
        public int width;
        public int height;
    }

    internal class MemoryBitmaps
    {
        public string name;
        public string x;
        public string y;       
        public Bitmap reducedBitmap;
        public int size;
        public int scale;
    }

    public class MovingProperties
    {
        public string name = "";
        public int width;
        public int height;
        public int speed;
        public int minX;
        public int maxX;
        public int minY;
        public int maxY;
     //   public bool memory = false;
    }

    public class MultiTextWriter : TextWriter
    {
        private IEnumerable<TextWriter> writers;
        public MultiTextWriter(IEnumerable<TextWriter> writers)
        {
            this.writers = writers.ToList();
        }
        public MultiTextWriter(params TextWriter[] writers)
        {
            this.writers = writers;
        }

        public override void Write(char value)
        {
            foreach (var writer in writers)
                writer.Write(value);
        }

        public override void Write(string value)
        {
            foreach (var writer in writers)
                writer.Write(value);
        }

        public override void Flush()
        {
            foreach (var writer in writers)
                writer.Flush();
        }

        public override void Close()
        {
            foreach (var writer in writers)
                writer.Close();
        }

        public override Encoding Encoding
        {
            get { return Encoding.ASCII; }
        }
    }

    public class ControlWriter : TextWriter
    {
        private Control textbox;
        public ControlWriter(Control textbox)
        {
            this.textbox = textbox;
        }

        public override void Write(char value)
        {
            textbox.Invoke((MethodInvoker)delegate () {
                textbox.Text += value;
            });            
        }

        public override void Write(string value)
        {
            textbox.Invoke((MethodInvoker)delegate () {
                textbox.Text += value;
            });
        }

        public override Encoding Encoding
        {
            get { return Encoding.ASCII; }
        }
    }
}
